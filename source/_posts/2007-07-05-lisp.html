---
layout: post
title: Lisp
categories: []
tags:
- lisp
status: publish
type: post
published: true
meta: {}
---
Sigo en la búsqueda del Nirvana computacional, tratando de romper con los ciclos eternos de castigo programando en lenguajes de programación comerciales.

A grandes rasgos esta ha sido mi búsqueda, casi como en los videojuegos donde inicias atrapado en una oscura celda en lo más profundo del castillo y debes subir y subir, sorteando todo tipo de obstáculos y aprendiendo técnicas que te hacen más poderoso cada vez.

<!--more-->


Va la lista:
<ul>
<li><strong>BASIC</strong> ¿Y quién no? El lenguaje perfecto para atrofiar el cerebro. Aunque ahora ya tenemos la versión actualizada, corregida y aumentada, usando Ruby como lenguaje, en <a href="http://hacketyhack.net/" title="hacketyhack" target="_blank">hacketyhack.</a></li>
<li><strong>Pascal</strong> Menos peor, primer acercamiento a apuntadores y variables por referencia</li>
<li><strong>C</strong> Al fin, un lenguaje de verdad. En ese tiempo pensaba que ya había logrado la iluminación, jaja, qué iluso. A pesar de eso uno de mis lenguajes favoritos</li>
<li><strong>Delphi</strong> Por primera vez programar algo que no fueran programas con entrada y salida de texto. Delphi fue un punto de inflexión en mi desarrollo profesional. Programas con interfaz gráfica, threads <strong>¡threads!</strong>, pero lo más importante, programación orientada a objetos. Cómo pude haber vivido tanto tiempo sin objetos. Me parecía que ahora si estaba en el camino correcto. Fui demasiado optimista, jaja</li>
<li><strong>C++</strong> C++ fue una cubetada de agua fría. Una cachetada con guante blanco. Un reto. Un lenguaje que gritaba, domíname si puedes. No pude. Al menos no en ese tiempo. Demasiado poderoso, demasiado Orientado a Objetos y sin ningún proyecto en donde aplicarlo y aprenderlo correctamente. Lo importante es que me mostró lo que era un verdadero lenguaje orientado a objetos. La lección aquí fue, siempre hay algo más allá del horizonte. C++ fue prometedor pero nunca logre hacer nada importante con él. Lástima, porque después llegaron otros lenguajes que me hicieron olvidar de C++ y nunca más pude regresar a él.</li>
<li><strong>Perl</strong> Perl, que sería de un ingeniero si nunca hubiera usado Perl. No sería ingeniero. Pero a mi no me gustó nadita. Si, era muy poderoso para manejar archivos de texto y sus expresiones regulares no tenían comparación, al menos en ese momento, pero desgraciadamente cuanto llegué al punto de intentar hacer una aplicación web usando Perl se acabó el encanto. CGI y variables de entorno para almacenar los parámetros del request POST y el GET. Era como hacer programación orientada a objetos usando C. Simplemente no era manejable. Al menos para mí.</li>
<li><strong>Java</strong> Directo de las oficinas de Sun Microsystems, yo, junto con miles más, nos tragamos la píldora de Java. Tan apetitosa que se veía, tan dulce en comparación con los bocadillos amargos que eran los demás lenguajes en comparación. Feliz como res al matadero corrí detrás del nuevo boom de la computación. No hay duda de que Java es muchísimo mejor que los demás lenguajes que había usado hasta el momento en muchas cosas (garbage collector, Orientación a Objetos, extensa biblioteca de clases, etc) pero todo era parte de una guerra de marketing a nivel mundial que no te permitía ver más allá. Y funcionó. Durante varios años fue reconfortante tener Java como herramienta. Y junto con Java llegaron los Applets y luego los Servlets. Todo parecía hermoso. Aplicaciones web sin problemas, portables, extensibles, la maravilla esperada por los programadores web. Pero entonces vinieron los JSPs, proclamando liberarnos del tedio de los Servlets (que hasta el día anterior eran la maravilla). Una nueva maravilla. Y más aún, con todo el tropel de ingenieros queriendo vivir de las aplicaciones web vinieron las estandarizaciones: J2EE. Oh desgracia. Lo que había empezado como una promesa del paraíso se volvió rápidamente en una mescolanza de técnicas, protocolos, estándares, archivos de configuración y frameworks que anunciaban facilitar todo este nuevo embrollo. A pesar de eso, Java me alimentó, junto con mi familia, durante todo ese tiempo. No me quejo de eso, me quejo de la promesa no cumplida y el desencanto provocado. La necesidad de buscar algo distinto (quizá mejor que Java) fue provocada por el mismo Java. La búsqueda tenía que continuar.</li>
<li><strong>Python</strong> Intenté entrar al mundo de Phyton. Parecía que era el lenguaje perfecto para dar el salto fuera de Java. Poderoso; todo es un objeto; muy interesante la manera de formatear el código fuente. Pero como fue el caso con C++, no encontré un proyecto donde pudiera usarlo de manera real. Fue mi primer intento con la nueva ola de lenguajes dinámicos (Perl pertenece a la vieja ola, ja)</li>
<li><strong>Ruby</strong> En medio de toda esta desesperación, encontré en <a href="http://slashdot.org" title="Slashdot" target="_blank">Slashdot</a> un artículo mencionando <a href="http://rubyonrails.org" title="Ruby On Rails" target="_blank">Ruby On Rails</a>, y así fue como conocí Ruby. Ruby es un lenguaje conciso y extraño a primera vista. Pocas cosas en común con lo que sabía. Pero aunque el lenguaje por si mismo tiene méritos suficientes para ser santo de mi devoción, sin el furor que Ruby On Rails estaba causando no hubiera pasado de ser otro Python (en el sentido de prometedor pero sin un uso práctico inmediato) para mí. Afortunadamente RoR fue el catalizador que logró que intentara un proyecto nuevo y pudiera aprender el lenguaje. Bueno, eso es otra historia.</li>
</ul>
Aun sigo aquí, en este ciclo con los lenguajes dinámicos. Pero mientras estoy aquí descubro que, a pesar del largo camino andado, hay un lenguaje que ha existido desde muchísimo antes que todos ellos y que no sólo hace todo lo que, de manera tosca, hacen los que yo había aprendido, sino que hace muchas cosas más, cosas completamente desconocidas e inimaginables.

Inicialmente creado en 1958, contemporáneo de FORTRAN (si, ese FORTRAN de los libros de historia de las computadoras) y que ha sobrevivido, abriendo camino, su propio camino, hasta nuestros días.

Lisp es su nombre.

Lisp como decía, ha recorrido su propio camino. Camino que todos los lenguajes que menciono han recorrido después quizá sin intención. Cuando el paradigma de programación orientada a objetos llegó a los usuarios de C para convertirse en C++, Lisp tenía años de haberlo incorporado y mejorado. Cuando Java popularizó el garbage collector y sus maravillas en reducción de tiempo de desarrollo para el programador ¡Lisp ya lo había inventado una década antes! Cuando Ruby me abrió los ojos a los closures y la metaprogramación, jaja, que creen, Lisp ya la tenía desde su inicio.

Y no sólo tenía todas estas características, sino que las tenía bien hechas. Las macros de Lisp son más que una cubetada de agua fría.  Es la aceptación de que somos por completo ignorantes el 99% de los que nos dedicamos a esto de la programación de sistemas. De los que pensamos en algún momento que Java era un buen lenguaje de programación.

Lisp es una ventana que muestra lo que hay afuera de nuestro reducido mundo de 4 paredes. Lisp es tiene casi 50 años y aun ahora patea los traseros de los demás lenguajes de programación que he usado. Y con una mano (o paréntesis) atrás.

Así que, aunque estoy en la etapa de Ruby y RoR para proyectos propios, y Java, JSPs y Struts para poder alimentarme, Lisp es el nuevo reto, el nuevo ciclo y potencialmente, el final de la búsqueda.

:D
